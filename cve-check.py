#!/usr/bin/env python3

import sqlite3
import argparse

CVE_COL_ID                 = 0
CVE_COL_VENDOR             = 1
CVE_COL_PRODUCT            = 2
CVE_COL_IS_PATCHED         = 3
CVE_COL_VERSION_START      = 4
CVE_COL_VERSION_START_INCL = 5
CVE_COL_VERSION_END        = 6
CVE_COL_VERSION_END_INCL   = 7

CVE_COLS = 'id, vendor, product, is_patched, version_start, version_start_inclusive, version_end, version_end_inclusive'

def get_query(vendor, product):
	if vendor == '*' and product == '*':
		return 'SELECT %s FROM cve' % (CVE_COLS), ()
	elif vendor == '*':
		return 'SELECT %s FROM cve WHERE product = ?;'  % (CVE_COLS), (product,)
	elif product == '*':
		return 'SELECT %s FROM cve WHERE vendor = ?;'  % (CVE_COLS), (vendor,)
	else:
		return 'SELECT %s FROM cve WHERE vendor = ? AND product = ?;'  % (CVE_COLS), (vendor, product)

def match_version(version, start, start_inclusive, end, end_inclusive):
	if version == '*':
		return True
		
	if start_inclusive:
		if version_compare(version, start) < 0:
			return False
	elif version_compare(version, start) <= 0:
		return False
		
	if end_inclusive:
		if version_compare(version, end) > 0:
			return False
	elif version_compare(version, end) >= 0:
		return False
	
	return True

def strip_leading_zeros(value):
	if value.startswith('0'):
		i = 0
		for c in value:
			if c == '0':
				i += 1
			elif c.isdigit():
				break
			else:
				i -= 1
				break
		if i > 0 and i < len(value):
			return value[i:]
	return value

def version_compare(a, b):
	if a == '*' or b == '*':
		return 0

	a_parts = a.split('.')
	b_parts = b.split('.')
	
	for i in range(max(len(a_parts), len(b_parts))):
		a_str = strip_leading_zeros(a_parts[i]) if i < len(a_parts) else '0'
		b_str = strip_leading_zeros(b_parts[i]) if i < len(b_parts) else '0'
		if a_str.isdigit() and b_str.isdigit():
			diff = int(a_str) - int(b_str)
			if 0 != diff:
				return diff
		else:
			if a_str > b_str:
				return 1
			elif a_str < b_str:
				return -1
				
	return 0

def make_version_range(start, start_incl, end, end_incl):
	return '%s%s,%s%s' % (
		'[' if start_incl else '(',
		start,
		end,
		']' if end_incl else ')'
	)

if __name__ == '__main__':
	parser = argparse.ArgumentParser(description='Check for CVE.')
	parser.add_argument('-f', '--file', type=str, default='cve.db', help='filename of database')
	parser.add_argument('-p', '--product', type=str, required=True, help='product')
	parser.add_argument('--vendor', type=str, default='*', help='vendor')
	parser.add_argument('--version', type=str, default='*', help='version')
	parser.add_argument('-v', '--verbose', default=False, action='store_true', help='verbose mode')
	parser.add_argument('-i', '--ignore', type=str, nargs='+', default=[], help='ignore CVE')
	parser.add_argument('--ignore-file', type=str, default='', help='file containig ignored CVEs')
	args = parser.parse_args()
	
	ignored_cves = args.ignore
	if not args.ignore_file == '':
		with open(args.ignore_file) as f:
			lines = f.readlines()
		lines = [line.strip() for line in lines]
		ignored_cves += lines
	
	query, query_args = get_query(args.vendor, args.product)
	
	db = sqlite3.connect(args.file)
	cursor = db.cursor()
	for row in cursor.execute(query, query_args):
		id         = row[CVE_COL_ID]
		start      = row[CVE_COL_VERSION_START]
		start_incl = True if row[CVE_COL_VERSION_START_INCL] == 1 else False
		end        = row[CVE_COL_VERSION_END]
		end_incl   = True if row[CVE_COL_VERSION_END_INCL] == 1 else False
		
		if id in ignored_cves:
			continue
		
		if match_version(args.version, start, start_incl, end, end_incl):
			if not args.verbose:
				print(id)
			else:
				cve_vendor = row[CVE_COL_VENDOR]
				cve_product = row[CVE_COL_PRODUCT]
				is_patched = True if row[CVE_COL_IS_PATCHED] == 1 else False
				print('%s\t%s\t%s\t%s\t%s' % (
					id,
					cve_vendor,
					cve_product,
					make_version_range(start, start_incl, end, end_incl),
					'PATCHED' if is_patched else 'UNPATCHED'
				))
	
	db.close()
